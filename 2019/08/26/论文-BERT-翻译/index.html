<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="BERT：预训练的深度双向Transformer语言模型" />
  

  
  
  
  
  
  
  <title>论文:BERT 翻译 | readyFly</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="BERT：预训练的深度双向Transformer语言模型">
<meta property="og:type" content="article">
<meta property="og:title" content="论文:BERT 翻译">
<meta property="og:url" content="https://readyfly.github.io/2019/08/26/论文-BERT-翻译/index.html">
<meta property="og:site_name" content="readyFly">
<meta property="og:description" content="BERT：预训练的深度双向Transformer语言模型">
<meta property="og:locale" content="Chinese">
<meta property="og:updated_time" content="2019-08-26T04:50:19.249Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="论文:BERT 翻译">
<meta name="twitter:description" content="BERT：预训练的深度双向Transformer语言模型">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
  <!--
  <script>
    (function(){
        if('{{ page.password }}'){
            if (prompt('请输入文章密码') == '{{ page.password }}'){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>
-->
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <a href="https://readyfly.github.io" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="readyFly" rel="home">readyFly</a>
      </h1>
      
        <script type="text/javascript" src="http://api.hitokoto.us/rand?encode=js&charset=utf-8"></script>
        <h2 class="site-description"><script>hitokoto();</script></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-论文-BERT-翻译" class="post-论文-BERT-翻译 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      论文:BERT 翻译
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://readyfly.github.io/2019/08/26/论文-BERT-翻译/" data-id="cjzs6k7ux002078vfy1fi1nh9" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>BERT：预训练的深度双向Transformer语言模型<br><a id="more"></a></p>
<h2 id="摘-要"><a href="#摘-要" class="headerlink" title="摘  要"></a>摘  要</h2><p>我们提出了一种新的语言表示模型——BERT，基于语言理解的深度双向Transformer的预训练模型。与最近的语言模型不同，BERT通过在所有层中对左右上下文进行联合调节来预先训练深度双向表示。因此，只需增加一个额外的输出层，就可以对预先训练的 BERT 进行微调，从而为各种任务创建效果较好的模型。例如问答和语言推理任务，无需对于特定任务而进行大量的模型修改。<br>BERT在概念上很简单，但实验结果很强大。它刷新了11项自然语言处理任务当前的最优结果，包括将GLUE基准提高到80.4%(绝对提高7.6%)、将MultiNLI的准确率提高到86.7%(绝对提高5.6%)、以及将SQuAD v1.1问答测试F1得分提高到93.2分(绝对提高1.5分) ——比人类测试还高出2分。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>语言模型预处理已被证明对提高许多自然语言处理任务是有效的。这些任务包括句子级任务，如自然语言推理和释义，其目的是通过对句子的全面分析来预测句子之间的关系；以及标记级别的任务，如命名实体识别和SQuAD问题回答，其中需要模型在标记级生成细粒度的输出。<br>目前有两种策略可以将预先训练好的语言模型应用于下游任务：基于特征的语言模型和微调。基于特征的方法, 如 ELMO, 使用特定于任务的模型结构, 其中包括预先训练的表示作为附加功能。微调方法, 如生成预训练Transformer模型，引入最小的特定于任务的参数, 并通过简单地微调预先训练的参数来对下游任务进行训练。在以前的工作中，这两种方法在预训练任务中都有相同的目标函数，即使用单向的语言模型来学习通用的语言表示。<br>我们认为, 目前的技术严重限制了预先训练的表示的能力, 特别是对微调的方法。主要的局限性在于使用的语言模型是单向的, 这限制了在预训练期间可以使用的模型结构的选择。例如, 在 OpenAI GPT 中, 作者使用了从左到右的模型结构, 其中每个标记只能在Transformer的自注意层中处理以前的标记。这种限制对于句子级任务来说是可以接受的, 但当吧基于微调的方法用来处理标记级的任务时，如SQuAD问题回答，可能造成不良的影响。因为在标记级任务中，从两个方向来分析上下文是至关重要的。<br>在本文中, 我们通过提出 BERT，改进了基于微调的方法：基于Transformer的深度双向编码器。受完形填空任务的启发，BERT通过提出一个新的预训练任务来解决前面提到的单向制约： “遮蔽语言模型” (MLM)，遮蔽语言模型从输入中随机屏蔽了一些词，目的是仅根据被遮蔽的词的上下文来预测它的原始词汇的 id。与从左到右的语言模型预训练不同，MLM允许表示将左、右上下文融合,这样我们就可以预先训练一个深度双向Transformer。除了遮蔽语言模型外, 我们还引入了一个 “下一句预测” 任务, 共同预训练文本。本文的贡献如下：<br>（1）我们展示了对语言表示进行双向预训练的重要性。与Radford 等人不同，它使用单向语言模型进行预训练，而BERT使用遮蔽语言模型来实现深度双向表示。这也与Peters 等人的研究形成对比, 他们使用的是独立训练的从左到右和从右到左的语言模型浅层连接。<br>（2）我们展示了预先训练的表示消除了许多重型工程特定任务对模型结构的需求。BERT是第一个基于微调的表示模型，它在大量的语句级和令牌级任务上实现了最先进的性能，优于许多具有特定于任务的模型结构。<br>（3）BERT推进了11项 NLP任务的最先进技术。我们还进行了大量的消融研究，证明了我们模型的双向特性是最重要的新贡献。代码和预训练的模型可在goo.gl/language/bert 获取。</p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p>预训练的通用语言表示历史源远流长, 我们将在本节中简要回顾所涉及到的最流行的几种方法。</p>
<h3 id="基于特征的方法"><a href="#基于特征的方法" class="headerlink" title="基于特征的方法"></a>基于特征的方法</h3><p>几十年来, 学习广泛适用的词语表示一直是一个活跃的研究领域, 包括非神经网络领域和神经网络领域。预先训练的单词嵌入被认为是现代 nlp 系统的一个不可分割的组成部分，词嵌入提供了比从头开始学习的显著改进。<br>这些方法已被推广到更粗的粒度, 如句子嵌入或段落嵌入。与传统的词嵌入一样，这些学习到的表示通常也用作下游模型中的特性。<br>ELMo从不同的维度概括了传统的词嵌入研究。他们建议从语言模型中提取对上下文敏感的特征。再将上下文词嵌入到现有的特定于任务的模型结构中时，ELMo为几个主要的NLP基准测试提供了最先进的技术，包括在SQuAD上的问答、情感分析和命名实体识别。</p>
<h3 id="基于微调的方法"><a href="#基于微调的方法" class="headerlink" title="基于微调的方法"></a>基于微调的方法</h3><p>语言模型迁移学习（LMs）的一个最新的趋势是，在对受监督的下游任务的模型进行微调之前，先对LM目标上的一些模型架构进行预训练。这些方法的优点是无需从头开始获取参数。至少大部分由于这种优势，OpenAI GPT在GLUE基准测试的许多句子级任务上取得了以前最先进的结果。</p>
<h3 id="从监督数据中迁移学习"><a href="#从监督数据中迁移学习" class="headerlink" title="从监督数据中迁移学习"></a>从监督数据中迁移学习</h3><p>虽然无监督的预训练的好处是, 现有的数据几乎是无限的, 但也有工作表明, 从监督下的任务中有效地转移了具有大数据集的监督任务, 如自然语言推断和机器翻译 。在 NLP之外, 计算机视觉研究也证明了从大型预训练学习中进行迁移学习的重要性，其中一个有效的方法是可以微调在ImageNet上预训练的模型。</p>
<h2 id="BERT"><a href="#BERT" class="headerlink" title="BERT"></a>BERT</h2><p>本节将介绍BERT及其具体实现。我们首先介绍了BERT的模型结构和输入表示。然后，我们在3.3节中介绍了本文的核心创新——预训练任务。预训练和微调过程分别于第3.4和3.5节讲述。最后，在第3.6节中讨论了BERT和OpenAI GPT之间的差异。</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>BERT的模型架构是一个基于Vaswani等人提出的多层双向Transformer编码器，并在tensor2tensor中发布。由于近年来Transformer的使用变得无处不在，我们的实现实际上与最初的实现完全相同，所以我们将省略对模型架构的详尽背景描述，并推荐参考Vaswani等人(2017)以及优秀的指南，如“the Annotated Transformer”<br>在这项工作中，我们表示层数的数量(即，Transformer块)为L，隐藏层大小为H，自注意头个数为A。在所有情况下，我们将前馈/过滤器设置设为4H，即，当H = 768时，设置为3072；当H = 1024时，设置为4096。我们主要分析两个模型大小的结果：<br>•    BERT（base）：L=12，H=768，A=12，Total Parameters=110M<br>•    BERT（large）：L=24，H=1024，A=16，Total Parameters=340M<br>为了方便进行比较，选择BERT（base）与OpenAI GPT相同的模型大小。然而，关键的是，BERT Transformer使用双向的自我注意，而GPT Transformer使用约束的自我注意，其中每个令牌只能注意其左边的语境。我们注意到，在文献中，双向Transformer通常被称为“Transformer编码器”，而只包含左侧语境信息的被称为“Transformer 解码器”，因为它可以用于文本生成。BERT、OpenAI GPT和ELMo之间的比较如图1所示。</p>
<p>图1 ：预训练模型结构的不同。BERT使用双向Transformer。OpenAI GPT 使用 从左到右的 Transformer。ELMo 使用独立训练的从左到右和从右到左的 LSTM 的连接来为下游任务生成特征。其中，只有 BERT 表示在所有层中同时结合了左右语境的信息。</p>
<h3 id="输入表示"><a href="#输入表示" class="headerlink" title="输入表示"></a>输入表示</h3><p>我们的输入表示能够以一个标记序列清楚地表示单个文本句子或一对文本句子(例如，[Question, Answer])。对于给定的令牌，它的输入表示是通过对相应的令牌、句子和位置嵌入求和来构造的。图2给出了输入表示的可视化表示。<br>具体表示：</p>
<p>图 2：BERT 的输入表示。输入嵌入是标记嵌入（词嵌入）、句子嵌入和位置嵌入的总和。</p>
<p>•    我们使用文字片的嵌入, 具有 30000个令牌词汇。我们用“##”表示拆分的字片断。<br>•    我们使用学习到的位置嵌入, 支持的序列长度最长可达512个令牌。<br>•    每个序列的第一个标记始终是特殊的分类嵌入 ([CLS]) 该特殊标记对应的最终隐藏状态（即，Transformer 的输出）被用作分类任务中该序列的总表示。对于非分类任务，这个最终隐藏状态将被忽略<br>•    句子对被打包成一个序列。我们用两种方式区分句子。第一种方法, 我们用一个特殊的令牌 ([SEP])。第二种方法，我们给第一个句子的每个标记添加一个可训练的句子 A 嵌入，给第二个句子的每个标记添加一个可训练的句子 B 嵌入•    对于单句输入, 我们只使用句子A 嵌入。</p>
<h3 id="预训练任务"><a href="#预训练任务" class="headerlink" title="预训练任务"></a>预训练任务</h3><p>与Peters等人(2018)和Radford等人(2018)不同，我们不使用传统的从左到右或从右到左的语言模型对BERT进行预训练。相反，我们预先训练BERT使用本节描述的两个新的无监督预测任务。</p>
<h4 id="任务1：遮蔽语言模型"><a href="#任务1：遮蔽语言模型" class="headerlink" title="任务1：遮蔽语言模型"></a>任务1：遮蔽语言模型</h4><p>直观上，我们有理由相信，深度双向模型严格地比从左到右的模型或从左到右结合从右到左的模型的浅连接更强大。不幸的是，标准条件下语言模型只能训练为从左到右或从右到左，因为双向条件作用将允许每个单词在多层上下文中间接地“看到自己”。<br>为了训练一个深度的双向表示, 我们采用一种简单的方法来随机屏蔽输入标记词，然后只预测这些屏蔽掉的标记。我们将此过程称为 “遮蔽语言模型” (MLM)，尽管在文献中它经常被称为完形填空任务。在这种情况下，就像在标准语言模型中一样，与遮蔽标记相对应的最终隐藏向量被输入到与词汇表对应的输出softmax中。在我们所有的实验中，我们在每个序列中随机遮蔽 15% 的标记。与去噪的自动编码器（Vincent et al., 2008）不同的是，我们只是让模型预测被遮蔽的标记，而不是要求模型重建整个输入。尽管这确实允许我们获得双向预训练模型, 但这种方法有两个缺点。首先, 这造成预训练和微调之间的不匹配, 因为[MASK]标记在微调过程中永远不会被看到。为了缓解这种情况, 我们并不总是用用[MASK]标记替换被选中的标记。相反，我们随机选择15% 的标记，例如，在句子中my dog is hairy这句话中，它选择hairy。然后，执行以下过程：<br>•    不是总是将所选单词替换为[MASK]，数据生成器将执行以下操作:<br>•    80%的时间替换所选数据为[MASK]标记，例如：my dog is hairy  → my dog is [MASK]<br>•    10%的时间替换所选数据为一个随机的单词，例如：my dog is hairy  →  my dog is apple<br>•    10%的时间不改变所选的数据，例如：my dog is hairy  → my dog is hairy 这样做的目的是使表示偏向于实际观察到的单词。</p>
<p>Transformer编码器不知道它将被要求预测哪些单词，或者哪些单词已经被随机单词替换，因此它必须保留每个输入令牌的分布上下文表示。此外，因为随机替换只发生在所有令牌的1.5%（即，15% 的 10%）这似乎不会损害模型的语言理解能力。<br>使用MLM第二个缺点是，在每个批次中只能预测15%的令牌，这意味着模型可能需要更多的训练前步骤来收敛。在第5.3节中，我们证明MLM确实比从左到右的模型(它预测每一个标记)收敛稍微慢一点，但是MLM模型的改进效果远远超过要增加的训练成本。</p>
<h4 id="任务2-：下一句预测"><a href="#任务2-：下一句预测" class="headerlink" title="任务2 ：下一句预测"></a>任务2 ：下一句预测</h4><p>许多重要的下游任务，如问答(QA)和自然语言推理(NLI)，都是建立在理解两个文本句子之间的关系的基础上的，而语言建模并没有直接捕捉到这一关系。为了训练一个理解句子关系的模型，我们预先训练了一个二值化的下一个句子预测任务，这个任务可以从任何单语语料库中轻松生成。具体地说，在选择句子A和句子B的时候，50%的时间B是A后面的下一个实际句子，50%的时间是从语料库中随机抽取的句子。例如：</p>
<p>我们完全随机选择不是下一句的句子，最终的预训练模型在这个任务中达到了97%-98%的准确率。尽管这个任务很简单，但我们在5.1节中展示了其对QA和NLI任务进行预训练是非常有益的。</p>
<h3 id="预训练过程"><a href="#预训练过程" class="headerlink" title="预训练过程"></a>预训练过程</h3><p>预训练的过程主要遵循现有的语言模型预训练。对于预训练语料库，我们使用了BooksCorpus(8亿字)和英语维基百科(2.5亿字)。对于维基百科，我们只提取文本段落，而忽略列表、表格和标题。为了提取长的连续序列，关键是使用文档级别的语料库，而不是像十亿词基准那样使用打乱顺序的的句子级语料库。<br>为了生成每个训练输入序列，我们从语料库中抽取两段文本作为样本，我们称之为“句子”，尽管它们通常比单个句子长得多(但也可能更短)。第一个句子添加A嵌入，第二个句子添加B嵌入。50%的时间B是A之后的下一个句子，50%的时间B是一个随机的句子，这是为“下一句预测”任务而做的。它们的采样组合长小于等于512个令牌。语言模型掩码是在序列化句子后，采用15%的概率遮蔽标记，不考虑部分词片的影响（即那些含有被 WordPiece 拆分，以##为前缀的标记）。<br>我们使用256个序列(256序列* 512令牌= 128,000令牌/批)的批大小训练1,000,000个步骤，这大约是超过33亿单词库的40个周期。我们用Adam优化算法，并设置其学习速率为1e-4，β1 = 0.9，β2 = 0.999，L2的权重衰变为0.01。在第一个10000步学习速度热身，然后学习率开始线性衰减。我们在所有层上使用0.1的概率dropout。和OpenAI GPT一样，我们使用gelu激活函数而不是标准的relu函数。训练损失是遮蔽语言模型似然值与下一句预测似然值的平均值。<br>在4块云TPU(共16块TPU)上对BERT（base）进行训练。在16块云TPU(共64块TPU)上对BERT（large）进行训练。每次训练都需要4天的时间。</p>
<h3 id="微调过程"><a href="#微调过程" class="headerlink" title="微调过程"></a>微调过程</h3><p>对于序列级别的分类任务，BERT 微调非常简单。为了获得输入序列的固定维度的表示，我们取特殊标记（[CLS]）构造相关的嵌入对应的最终的隐藏状态(即，为 Transformer 的输出)的池化后输出。我们把这个向量表示为C∈R^H ，在微调期间唯一需要的新增加的参数是分类层的参数矩阵W∈R^(K×H) ，其中”K” 是要分类标签的数量。分类标签的概率P∈R^K 由一个标准的softmax 来计算，P=softmax(CW^T)。对 BERT 的参数矩阵W的所有参数进行了联合微调，使正确标签的对数概率最大化。对于区间级和标记级预测任务，必须以特定于任务的方式稍微修改上述过程。具体过程见第 4 节的相关内容。<br>对于微调, 大多数模型超参数与预训练中的模型相同, 除了批处理大小、学习速率和训练次数。Dropout概率始终保持在0.1。最佳的超参数值是特定于任务而言的，但我们发现以下范围内可能的值可以很好地在所有任务中工作：<br>•    批处理大小：16，32<br>•    学习率：5e-5，3e-5，2e-5<br>•    训练次数：3，4<br>我们还观察到，与小数据集相比，大数据集(例如，100k+标记的训练示例)对超参数选择的敏感度要低得多。微调通常非常快，因此可以简单地对上述参数进行彻底的搜索，并选择在验证集上性能最好的模型。</p>
<h3 id="比较BERT和OpenAI-GPT"><a href="#比较BERT和OpenAI-GPT" class="headerlink" title="比较BERT和OpenAI GPT"></a>比较BERT和OpenAI GPT</h3><p>与BERT最相似的预训练方法是OpenAI GPT，它在一个大型文本语料库上训练一个左向右转换的Transformer语言模型。事实上，BERT中的许多设计决策都是有意地选择尽可能接近GPT，以便将这两种方法进行最小程度的比较。我们工作的核心论点是，在 3.3 节中提出的两项新的预训练语言模型任务占了实验效果改进的大部分，但是我们注意到 BERT 和 GPT 在如何训练方面还有其他几个不同之处：<br>•    GPT 是在 BooksCorpus（800M 词）上训练出来的；BERT 是在 BooksCor-pus（800M 词）和 Wikipedia（2,500M 词）上训练出来的。<br>•    GPT 仅在微调时使用句子分隔符（[SEP]）和分类标记（[CLS]）；BERT 在预训练时使用 [SEP]， [CLS] 和 A/B 句嵌入。<br>•    GPT 在每批次含 32,000 词上训练了 1M 步；BERT 在每批次含 128,000 词上训练了 1M 步。<br>•    GPT 在所有微调实验中学习速率均为 5e-5；BERT 选择特定于任务的在验证集中表现最好的微调学习率。<br>图 3：我们具体于特定任务的模型是通过给 BERT 加一个额外的输出层构成，所以仅需要从头学习最小数量的参数。其中（a）和（b）是序列级任务，（c）和（d）是标记级任务。图中  表示嵌入的输入， 表示第  个标记的上下文表示，[CLS] 是分类输出的特殊符号，[SEP] 是分离非连续标记（分离两个句子）序列的特殊符号。<br>为了分清楚这些差异的带来的影响，我们在 5.1 节中进行了每一种差异的消融实验，大多数的实验效果的改善实际上来自新的预训练任务（遮蔽语言模型和下一句预测任务）。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>在这一部分，我们呈现了在11项NLP任务中用BERT微调的结果。</p>
<h3 id="GLUE数据集"><a href="#GLUE数据集" class="headerlink" title="GLUE数据集"></a>GLUE数据集</h3><p>通用语言理解评估(GLUE)基准是各种自然语言理解任务的集合。大多数数据集已经存在好几年了，GLUE的目的是：1）数据集使用规范的训练集、验证集和测试集格式 2）设置评估服务器，以缓解评估不一致和测试集过度拟合的问题。GLUE不分发测试集的标签，用户必须将他们的预测上传到GLUE服务器进行评估，并限制提交的数量。<br>GLUE包括以下数据集（最原始的描述来自Wang et al. (2018)）。<br>MNLI：多体裁自然语言推理是一个大规模的、众包的包含分类的任务(Williams等人，2018)。给出一对句子，目的是预测第二个句子相对于第一种是暗含的、矛盾的还是中立的关系。<br>QQP：Quora问题对是一个二进制分类任务，目标是确定在Quora上提出的两个问题在语义上是否等价。<br>QNLI：问题自然语言推理是斯坦福问答数据集(Rajpurkar等人，2016)的一个版本，该数据集已被转换为二进制分类任务(Wang等人，2018年)。正类的例子是(问题，句子)对，其中包含正确的答案，而负类的例子是(问题，句子)来自同一个段落，句子中不包含正确的答案。<br>SST-2：斯坦福情感树库是一个二元单句分类任务，由从电影评论中提取的句子组成，并附有对其情感方面的人工注释。<br>CoLA：语言可接受性语料库是一个二元单句分类任务，其目的是预测一个英语句子在语言上是否“可接受”。(是否正确合理)<br>STS-B：语义文本相似性基准是从新闻标题和其他来源抽取的句子对的集合(Cer等人，2017)。它们被注释为从1到5的分数，表示这两个句子在语义上的相似程度。<br>MRPC：微软研究释义语料库由自动从在线新闻源中提取的句子对组成，并对这对语句中的句子是否在语义上相等进行了人工注释。(Dolan和Brockett，2005年)。<br>RTE：识别文本包含是一项与MNLI类似的二进制包含任务，但是训练数据要少得多。<br>WNLI：威诺格拉德自然语言推理是派生于(Levesque等人，2011年)的一个小型自然语言推理数据集。GLUE指出这个数据集的构造可能有问题。每一个提交给GLUE训练的系统的性能比预测大多数类的65.1基准精度差。因此，对OpenAI GPT公平起见，我们排除了这种情况。</p>
<h3 id="GLUE结果"><a href="#GLUE结果" class="headerlink" title="GLUE结果"></a>GLUE结果</h3><p>为了在GLUE上微调模型，如第3节所述，我们表示输入句子或句子对，并使用与第一个输入令牌([CLS])对应的最后一层隐藏向量C∈R^H作为聚合表示。如图3、4所示。在微调过程中引入的唯一新参数是一个分类层参数矩阵W∈R^(K×H)，其中K是标签的数量。我们用C和W计算标准分类损失，也就是log⁡(softmax(CW^T))<br>我们在数据上使用32批次大小和3个周期。对于每个任务，我们使用5e-5, 4e-5, 3e-5 和2e-5 的学习率来微调，从中选择最优学习率。另外，对于BERT-large的微调，在小数据集上是不稳定的。（一些运行会产生退化的结果。）因此，我们运行了几次随机重新启动，并选择了在验证集上表现最好的模型。对于随机重新启动，我们使用相同的预先训练的检查点，但执行不同的细化数据和分类器层初始化来微调模型。我们注意到GLUE数据集分布没有包含测试标签，我们分别将BERT-BASE和BERT-LARGE 向 GLUE 评估服务器提交结果。<br>结果如表1所示。BERT-BASE和BERT-LARGE在所有任务上的表现都大大超过了所有现有系统，平均精度提高了4.4%和6.7%是最先进的。请注意，BERT-BASE和OpenAI GPT在注意掩蔽之外的模型结构方面几乎是相同的。对于最大和最广泛报道的GLUE任务MNLI ，BERT获得了4.7%的绝对准确度相对先进水平。在官方GLUE排行榜上，BERT-LARGE获得了80.4分，与原榜首的 OpenAI GPT 相比，截止本文写作时它只获得了72.8 分。<br>有趣的是，BERT-LARGE在所有任务上都明显优于BERT-BASE，即使是那些训练数据很少的任务。我们在5.2部分更深入地探讨了BERT模型尺寸的影响。</p>
<p>   表1  GLUE 测试结果，由 GLUE 评估服务器评分。每个任务下面的数字表示训练示例的数量。“Average”列与官方 GLUE 评分略有不同，因为我们排除了有问题的 WNLI 数据集。OpenAI GPT = (L=12, H=768, A=12); BERTBASE = (L=12, H=768, A=12); BERTLARGE = (L=24, H=1024, A=16)。BERT 和 OpenAI GPT 都是单模型，单任务。所有结果可以从 gluebenchmark.com/leaderboard 和 blog.openai.com/language-un… 获得。</p>
<h4 id="SQuAD-v1-1"><a href="#SQuAD-v1-1" class="headerlink" title="SQuAD v1.1"></a>SQuAD v1.1</h4><p>斯坦福问答数据集是由100 k个众包的问题/答案对组成的集合。给出一个问题和维基百科中包含这个问题的答案的段落，任务是预测段落中的答案文本标签。例如：<br>•    输入问题： Where do water droplets collide with ice crystals to form precipitation?<br>•    输入段落 … Precipitation forms as smaller droplets coalesce via collision with other rain drops or ice crystals within a cloud. …<br>•    输出答案 within a cloud</p>
<p>这种类型的跨度预测任务与GLUE的序列分类任务有很大的不同，但是我们能够使BERT以一种简单的方式在SQuAD上运行。与之前的GLUE数据一样，我们将输入问题和段落表示为一个单一的填充序列，问题使用A嵌入，段落使用B嵌入。在微调过程中学到的唯一新参数是起始向量S∈R^H和终止向量E∈R^H。让BERT模型最后一层隐藏向量的第i^th输入标记被表示为 T_i∈R^H，可参考图3(c)。然后，计算单词 i 作为答案区间开始的概率，它是T_i和S之间的点积并除以该段落所有单词的结果之后再softmax：</p>
<p>同样的式子用来计算单词作为答案区间的结束的概率，并采用得分最高的区间作为预测结果。训练目标是正确的开始和结束位置的对数可能性。<br>我们训练了3个周期，学习率为5e-5，批次大小为32。在推理时，由于结束位置和开始位置没有条件关系，因此我们添加了一个约束，即结束位置必须是从开始位置之后的条件，但是没有使用其他的启发式方法。为了方便评估，将标记为span的标记返回到原始未标记化输入以进行评估。<br>结果见表2。SQuAD使用高度严格的测试程序，提交者必须手动与SQuAD组织者联系，以便在隐藏的测试集上运行他们的系统，所以我们只能使用我们最好的系统来测试。表中显示的结果是我们第一次也是唯一次向小组提交测试结果。我们注意到上面的结果在小组排行榜上没有最新的公共模型描述，并被允许在训练他们的模型时使用任何的公共数据。因此，我们在提交的模型中使用非常有限的数据增强，通过在 SQuAD 和 TriviaQA(Joshi et al., 2017) 联合训练。<br>表2     SQuAD 结果。Ensemble BERT 是使用不同的预训练模型检查点和微调种子的 7x 模型。<br>我们表现最好的模型在集成模型排名中上比排名第一模型高出1.5 F1，在一个单模型排行榜中比排名第一的模型高出 1.3 F1。事实上，我们的单一Bert模型在性能上就优于最优的集成模型。如果我们只在SQuAD微调(没有TriviaQA)，我们会损失掉0.1-0.4 F1值，但是仍然在很大程度上超过所有现有的模型。</p>
<h4 id="命名实体识别"><a href="#命名实体识别" class="headerlink" title="命名实体识别"></a>命名实体识别</h4><p>为了评估标记任务的性能，我们对CoNLL 2003命名实体识别(NER)数据集上的进行了BERT微调。此数据集由200 k训练单词组成，它们被注释为人员、组织、地点、杂项或其他(未命名实体)<br>为了进行微调，我们将最后的隐藏表示T_i∈R^H提供给每个令牌i到NER标签集上的分类层中。这些预测不取决于周围的预测(即无自回归和CRF)。为了使其与WordPiese标记化兼容，我们将每个CoNLL标记化输入字输入到WordPiece标记器中，并使用与第一个标记对应的隐藏状态。使用对应的隐藏状态做为输入的第一个子token。例如：</p>
<p>其中没有对X进行预测。由于WordPiese标记化边界是输入的一个已知部分，因此对于训练和测试都这样做。结果如表3 所示。BERT-LARGE优于现存的最优模型，使用多任务学习的交叉视野训练 (Clark et al., 2018)，CoNLL-2003 命名实体识别测试集上高 0.2 F1 值。</p>
<p>表3 CoNLL-2003 命名实体识别。模型超参数使用验证集进行选择，报告的验证集和测试分数使用这些超参数进行随机五次以上的实验然后取实验的平均结果。</p>
<h4 id="SWAG"><a href="#SWAG" class="headerlink" title="SWAG"></a>SWAG</h4><p>SWAG数据集包含了113K句子对完成示例，用于评估基本常识推理。根据视频标题数据集中的句子，任务是在四种选择中确定最合理的延续。例如：<br>使BERT使用与该数据集和GLUE数据集类似。对于每个例子，我们构造了四个输入序列，每个序列包含给定句子(A句)的级联和一个可能的延续(B句)。概率分布是四种选择的最大概率（softmax）：</p>
<p>我们使用 2e-5 的学习率，16 的批次大小训练模型 3 个周期。结果如表 4 所示。BERT-LARGE优于作者的 ESIM+ELMo 的基线标准模型的 27.1% 。<br>表 4：SWAG 验证集和测试集准确率。测试结果由 SWAG 作者对隐藏的标签进行评分。人类的表现是用 100 个样本来衡量的，正如 SWAG 论文中描述的那样。</p>
<h4 id="消融研究"><a href="#消融研究" class="headerlink" title="消融研究"></a>消融研究</h4><p>尽管我们已经展示了非常有力的实证结果，但迄今提出的结果并没有将BERT框架的各个方面的具体贡献分开。在本节中，我们对BERT的多个方面进行实验，以便更好地理解它们的相对重要性。</p>
<h3 id="预训练任务的影响"><a href="#预训练任务的影响" class="headerlink" title="预训练任务的影响"></a>预训练任务的影响</h3><p>我们的核心观点之一是BERT的深度双向性，它是通过MLM来实现的，与以前的工作相比，它是BERT最重要的改进之一。为了对这个给出证明，我们评估了两个新的模型，它们使用了与BERTBASE完全相同的预训练数据、微调方案和Transformer超参数。<br>1、NO NSP：一种使用“MLM”训练但没有“下一句预测”(NSP)任务的模型。<br>2、LTR &amp; No NSP：模型使用一个从左到右（LTR）的语言模型，而不是遮蔽语言模型。在这种情况下，我们预测每个输入词，不应用任何遮蔽。在微调中也应用了仅限左的约束，因为我们发现使用仅限左的上下文进行预训练和使用双向上下文进行微调总是比较糟糕。此外，该模型未经预测下一句任务的预训练。这与OpenAI GPT有直接的可比性，但是使用更大的训练数据集、输入表示和微调方案。<br>结果如表5所示。我们首先检查NSP任务所带来的影响。我们可以看到，移除NSP对QNLI、MNLI和SQuAD.的性能都有很大的影响。这些结果证明了我们的预训练方法对于获得先前提出的强有力的经验结果是至关重要的。</p>
<p>表5 在预训练任务中使用  模型进行消融实验。“No NSP”表示不进行下一句预测任务来训练模型。“LTR &amp; No NSP”表示就像 OpenAI GPT 一样，使用从左到右的语言模型不进行下一句预测任务来训练模型。“+ BiLSTM”表示在“LTR &amp; No NSP”模型微调时添加一个随机初始化的 BiLSTM 层。</p>
<p>接下来，我们通过比较“No NSP”和“LTR&amp;No NSP”来评估双向表示法的效果。LTR模型在所有任务上的性能都比MLM模型差，下降幅度非常大。 在MRPC和SQuAD上。对于SQuAD来说，很明显LTR模型在SPAN和令牌预测方面表现很差，因为令牌级隐藏状态没有右侧上下文。对于MRPC，不清楚性能不佳是由于小数据大小还是由于任务的性质，但是我们发现这种糟糕的性能在与包含多个随机重新启动的全超参数一样。<br>为了尝试加强LTR系统，我们在其基础上添加了一个随机初始化的BiLSTM，以便进行细化。<br>这确实大大提高了在SQuAD上的效果，但结果仍然比双向模型差。这也损害了在所有四个GLUE任务的性能。<br>我们认识到，还可以培训单独的LTR和RTL模型，并将每个令牌表示为这两种模型的级联，就像Elmo所做的那样。但是：(A)这是费用的两倍 作为一个单一的双向模型；(B)对于QA这样的任务来说，这是不直观的，因为rtl模型无法对问题的答案进行限定；(C)它的功能比深度双向模型要弱得多，因为深度双向模型可以选择使用左或右上下文。</p>
<h3 id="模型大小的影响"><a href="#模型大小的影响" class="headerlink" title="模型大小的影响"></a>模型大小的影响</h3><p>在这一部分中，我们探讨了模型大小对微调任务精度的影响。我们训练了许多不同层次、隐藏单位和注意力头的BERT模型，而在其他情况下，则使用与前面描述的相同的超参数和训练过程。<br>表6显示了所选GLUE任务的结果。在此表中，我们报告了5次随机重新启动微调的平均Dev集精度。我们可以看到，更大的模型在所有四个数据集上都会带来严格的准确性改进，甚至对于只有3600个标记的训练示例的MRPC来说也是如此，这与PRE有很大的不同。同样令人惊讶的是，我们能够在相对于现有文献已经相当大的模型之上实现如此重大的改进。例如，Vaswani et al.(2017) 研究的最大 Transformer 为(L=6, H=1024, A=16)，编码器参数为 100M，我们所知的文献中的最大 Transformer 为(L=64, H=512, A=2)，参数为235M（Al-Rfou et al., 2018）。相比之下，BERT-BASE含有110M 参数，而BERT-LARGE含有340M 参数。<br>多年来人们都知道，增加模型大小将导致大规模任务(如机器翻译和语言建模)的不断改进。表6所示的持久化训练数据的LM就证明了这一点。<br>然而，我们认为这是第一次证明，如果模型已经得到了足够多的预训练，那么将其扩展到极端的规模，也可以在非常小的任务上带来巨大的改进。<br>表6 调整 BERT 的模型大小。#L = 层数；#H = 隐藏维度大小；#A = 注意力头的个数。“LM (ppl)”表示遮蔽语言模型在预留训练数据上的困惑度。</p>
<h3 id="训练步骤次数影响"><a href="#训练步骤次数影响" class="headerlink" title="训练步骤次数影响"></a>训练步骤次数影响</h3><p>图 4 显示了经过 K 步预训练模型的检查点再模型微调之后在 MNLI 验证集上的准确率。这让我们能够回答下列问题：<br>1、BERT真的需要这么多的预训练 BERT (128,000words/batch * 1,000,000 steps)才能达到高的微调精度吗？<br>答：是的，BERTBASE在MNLI上获得了接近1.0%的额外精度，当训练在1M级时，而不是500 K级。<br>2、MLM预训练的收敛速度是否比LTR预训练慢，因为每批只预测15%的单词，而不是每个单词？<br>答：MLM模型的收敛速度确实比LTR模型稍慢。然而，在绝对精度方面，MLM模型几乎立即开始优于LTR模型。<br>图4 调整模型的训练步数。图中展示了已经预训练了 k 步后的模型参数在 MNLI 数据集上的再经过微调后的准确率。x 轴的值就是 k。</p>
<h3 id="基于特征的BERT方法"><a href="#基于特征的BERT方法" class="headerlink" title="基于特征的BERT方法"></a>基于特征的BERT方法</h3><p>所有的 BERT 结果到目前为止, 本文采用了微调方法，在预训练的模型中添加了一个简单的分类图层, 并根据下游任务对所有参数进行了联合微调。但是, 基于特征的方法，即从预训练模型中提取固定的特征，也具有一定的优势。首先, 并非所有 NLP任务都可以很容易地由Transformer编码器表示, 因此需要添加特定于任务的模型体系结构。第二, 有主要的计算能够预先计算一次训练数据的昂贵表示形式, 然后在这种表示的基础上使用成本较低的模型运行许多实验, 这带来了最大的好处。<br>在本节中, 我们评估 BERT 在基于特征的方法, 方法是在  CoNLL-2003 命名实体识别任务上生成类似于 ELMO的预训练上下文表示形式。为此, 我们使用与4.3节中相同的输入表示形式，但是使用来自一个或多个层的激活输出，而不需要对BERT的任何参数进行微调。在分类层之前，这些上下文嵌入被用作对一个初始化的两层 768 维 Bi-LSTM 的输入。<br>结果如表7所示。最佳的执行方法是从预训练的转换器的前 4 个隐藏层串联符号表示，这只比整个模型的微调落后 0.3 F1 值。这表明 BERT对于微调和基于特征的方法都是有效的。<br>表7  在 CoNLL-2003 命名实体识别上使用基于特征的方法，并调整 BERT 层数。来自指定层的激活输出被组合起来，并被送到一个两层的 BiLSTM 中，而不需要反向传播到 BERT。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>使用语言模型进行迁移学习而取得的实验提升表明，丰富的、无人监督的预训练是许多语言理解系统的组成部分。特别是这些结果让低资源任务能够从非常深入的单向体系结构中受益的影响。我们的主要贡献是进一步将这些发现融合在深层双向结构中, 允许相同的预训练模型成功地处理一系列广泛的 NLP 任务。<br>虽然这些实证结果很有说服力，甚至在某些情况下超过了人类现有的表现。但未来重要的工作是研究 BERT 可能捕捉到的或不能捕捉到的语言现象。</p>
<p>译文原文出处： Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/08/26/论文-BERT-翻译/">
    <time datetime="2019-08-26T04:43:55.000Z" class="entry-date">
        2019-08-26
    </time>
</a>
    
    
    </footer>
</article>


  
  <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80MTY4MC8xODIyNg==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
  




</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2019/08/26/实战篇——达观杯比赛，信息抽取/">实战篇——达观杯比赛，信息抽取</a>
          </li>
        
          <li>
            <a href="/2019/08/26/主动学习/">主动学习</a>
          </li>
        
          <li>
            <a href="/2019/08/26/论文-BERT-翻译/">论文:BERT 翻译</a>
          </li>
        
          <li>
            <a href="/2019/08/26/nlp/">nlp</a>
          </li>
        
          <li>
            <a href="/2019/08/21/NLP自然语言处理/">NLP自然语言处理</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-库函数/">C++ 库函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K-means-无监督学习/">K-means 无监督学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/K近邻/">K近邻</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hello-world/">hello world</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-博客/">hexo 博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-sklearn机器学习/">python sklearn机器学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前序、中序、后序遍历/">前序、中序、后序遍历</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前缀、中缀、后缀表达式/">前缀、中缀、后缀表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/双向循环链表/">双向循环链表</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序算法/">排序算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/操作系统/">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路径算法-dijkstra算法-floyd算法/">最短路径算法 dijkstra算法 floyd算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络/">计算机网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心算法/">贪心算法</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/C-库函数/" style="font-size: 10px;">C++ 库函数</a> <a href="/tags/K-means-无监督学习/" style="font-size: 10px;">K-means 无监督学习</a> <a href="/tags/K近邻/" style="font-size: 10px;">K近邻</a> <a href="/tags/hello-world/" style="font-size: 10px;">hello world</a> <a href="/tags/hexo-博客/" style="font-size: 10px;">hexo 博客</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/python-sklearn机器学习/" style="font-size: 10px;">python sklearn机器学习</a> <a href="/tags/前序、中序、后序遍历/" style="font-size: 10px;">前序、中序、后序遍历</a> <a href="/tags/前缀、中缀、后缀表达式/" style="font-size: 10px;">前缀、中缀、后缀表达式</a> <a href="/tags/动态规划/" style="font-size: 10px;">动态规划</a> <a href="/tags/双向循环链表/" style="font-size: 10px;">双向循环链表</a> <a href="/tags/排序算法/" style="font-size: 10px;">排序算法</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/最小生成树/" style="font-size: 10px;">最小生成树</a> <a href="/tags/最短路径算法-dijkstra算法-floyd算法/" style="font-size: 10px;">最短路径算法 dijkstra算法 floyd算法</a> <a href="/tags/算法/" style="font-size: 20px;">算法</a> <a href="/tags/计算机网络/" style="font-size: 10px;">计算机网络</a> <a href="/tags/贪心算法/" style="font-size: 10px;">贪心算法</a>
    </div>
  </aside>

  
    <p class="asidetitle">打赏他</p>
<div>
<form action="https://shenghuo.alipay.com/send/payment/fill.htm" method="POST" target="_blank" accept-charset="GBK">
    <br/>
    <input name="optEmail" type="hidden" value="your 支付宝账号" />
    <input name="payAmount" type="hidden" value="默认捐赠金额(元)" />
    <input id="title" name="title" type="hidden" value="博主，打赏你的！" />
    <input name="memo" type="hidden" value="你Y加油，继续写博客！" />
    <input name="pay" type="image" value="转账" src="http://7xig3q.com1.z0.glb.clouddn.com/alipay-donate-website.png" />
</form>
</div>
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 Feng_linhui
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次, 访客数 <span id="busuanzi_value_site_uv"></span> 人次, 本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次

</footer>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/love.js"></script>
  <!--
 <embed src="//music.163.com/style/swf/widget.swf?sid=528283&type=2&auto=1&width=320&height=66" width="340" height="86"  allowNetworking="all"></embed>
 <img src = "/upload_image/cute.gif" width ="100" height="180" />
 -->
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":50,"height":150},"mobile":{"show":true}});</script></body>
</html>